
# Logic gating

Logic gating (wrt. clock gating) is a technique used to reduce
toggling (and so energy consumption) in digital logic circuits.

- If I have an an ALU with two functions, ADD or XOR, then I don't
  want the adder to toggle needlessly (and leak) when using the XOR
  function.

- I then bitwise AND the inputs to the adder (*higher up*) in the circuit
  with the `add_select` bit. This zeros the inputs the adder, preventing
  downstream toggling from glitches.

This is a common technique in low-power, energy efficient designs
where high frequency of operation is not needed.
It is particularly effective for preventing values "escaping" onto
something like a high-drive strength path like a memory bus.


**Questions:**

1. How does logic gating effect leakage?

   - Do certain paths benefit more or less from gate leakage?

   - Is it still effective in the context of an FPGA design?

2. If how logic gating changes the leakage is understood, can we exploit
   this?

   - If we know that two different intermediate results will be computed
     from the same operands, can we add this to our estimates?


**Hypotheses:**

- The "noise" generated by un-used computations in a non-gated design will
  reduce leakage in cases where the additional computations are not modelled.

- The extra toggling in a non-gated design will cause *more* leakage, if that
  toggling can be modelled.

- There will be more leakage in a comprehensivley modelled, non-gated
  design than a gated design.

---

# Experiments:

This experiment is nigh on impossible to do on an ASIC, since
we have no idea what is and is not logic gated.
Such an experiment would only really be possible on the in-house
CPU core, which we have lots of knowledge (and *understanding*) about, and
which can be modified as needed.

Alternatively, we could construct a representative example system.
This could consist of a simple ALU, where the operands are fed by registers
and we can select the output from one of several functions within the 
ALU.

**Setup:**

- Identify parts of the CPU which are amenable to logic gating:
  
  - This can be guided by analysing waveforms of a target application, and
    noting which signals have the highest probability of toggling per
    clock cycle.

  - It can also be done simply by observing where in the CPU the same data
    feeds mutually exclusive logic blocks.

- Having identified a managable number of blocks (N=~3) suitable for gating,
  create a set of implementation parameters allowing gating to be turned on
  or off easily.

**Experiment:**

- For each combination of logic gate enable parameters:
  
  - Capture the area / timing impact
  
  - Perform a standard t-test on some code kernel (1 AES round?)

- Compare average / peak leakage across parameters

  - Which parameter values corrolate with high/low leakage.

---

[Back Home](../../README.md)

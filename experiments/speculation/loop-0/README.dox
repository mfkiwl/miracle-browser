/*!

@defgroup experiments-speculation-loop-0 Loop Branch Shadow 0
@ingroup  experiments-speculation
@brief Do we see leakage from un-executed/partially executed instructions?

@see @ref experiments-speculation-jump-shadow-0
@see @ref experiments-speculation-loop-0
@see @ref experiments-speculation-loop-1

## Purpose:

- The simplest form of static branch prediction is "always predict taken"
  of "always predict taken if backwards".

- If a CPU implements this, then looping code should have no branch shadow,
  and instructions in the shadow of a branch should not be even
  partially exectued.

## Method:

- Create a simple empty loop, which iterates 8 times.

- The instruction following the end of the loop (immediately after the
  branch instruction) is an `xor`, with a TTest variable as one of
  it's operands.

## Expectations:

- If either the "always predict taken" or "always predict taken if backwards"
  static branch prediction rules are implemented, then we should never
  see the `xor` instruction leakage.

  - Note that this experiment  assumes that the target device has a leaky
    branch shadow of depth at-least `1`.

  - If that assumption does not hold, no leakage will be visible.

## Running the experiment

To run all stages of the experiment for a particular target device:

```
make -B USB_PORT=[PORT] UAS_TARGET=[TARGET] flow-speculation-loop-0
```

Where:
- `[PORT]` Is the UART/Serial port to communicate with it over.
- `[TARGET]` Is one of the target names listed in @ref targets

This will run all of the build, program, capture and analyse steps for
the experiment on the specified target.

The individual steps of the experiment are run with the following commands:

- Build: `make build_[TARGET]_speculation-loop-0`
- Program: `make program_[TARGET]_speculation-loop-0`
- Capture: `make capture_[TARGET]_speculation-loop-0 USB_PORT=[PORT]`
- Analyse: `make analyse_[TARGET]_speculation-loop-0`

*/

/*!

@defgroup experiments-speculation-jump-shadow-0 Static Branch Shadow
@ingroup  experiments-speculation
@brief Do we see leakage from un-executed/partially executed instructions?

@see @ref experiments-speculation-jump-shadow-0
@see @ref experiments-speculation-loop-0
@see @ref experiments-speculation-loop-1
@see @ref experiments-speculation-unpredictable-0

## Purpose:

Without a branch predictor, almost all scalar CPU pipelines must do
a degree of un-intended speculative exection.

- This is because for a conditional branch, the CPU may assume that
  the branch is (not) taken, and execute accordingly.

- This will fill the pipeline with instructions which (may) need to
  be thrown away.

- It is possible that this sort of behaviour means that instruction
  operands may be read (and even results computed) for instructions which
  from a software perspective are never executed.

- While this behavior is most likely for conditional (and hence harder to
  predict) branches, it possibly occurs for static branches too.

## Method:

- Execute a branch to relative address instruction (branch immediate)
  which jumps *over* an `xor` instruction.

  - The `xor` instruction uses two TTest variables as it's operands.

  - Theoretically, the `xor` instruction should *never* be executed, but
    if it gets far enough down the pipeline before the preceeding branch
    is executed, then it may read operands / be partially executed
    before being thrown away.

  - The branch distance is always forwards, and over some padding nops
    after the `xor`.

- This method is repeated, with between `0` and `4` NOP instructions
  inserted between the `xor` and the `branch`.

  - This allows us to detect how long the "shaddow" of the branch is.
    I.e. how many (if any) instructions are partially executed after
    a branch instruction.

- The start of the benchmark includes an `xor` instruction which is
  always executed with a TTest variable as an operand. This
  acts as a baseline so that subsequent leakages can be easily
  identified.

@note For the ARMv6m and ARMv7m architectures, the XOR instruction
    exhibits overwrite behaviour, where one operand is also
    the destination. This means that between each sub-experiment
    (i.e. for each new number of padding NOPS), the "left" operand
    is re-set by moving it back from a saved temporary register
    before each run.
    This means we should expect some hamming weight leakage on the
    left operand every time, potentially interspersed with
    speculative leakage.

## Expectations:

- If there is no partial execution of the `xor` instructions in the
  shadow of the branches, then there will be no leakage.

- If the instructions enter the pipeline in the shadow of the branch,
  but do not get far enough into the pipeline to start reading their
  operands, there will be no leakage.

- If the instruction enter far enough into the pipeline to read their
  operands, there will be hamming weight leakage.

- If the instructions progress far enough down the pipeline to
  compute their result, then there will be hamming weight leakage
  of the result as well as the inputs.

  - For the XOR instruction, this is the hamming distance of the
    two input TTest variable operands.

## Running the experiment

To run all stages of the experiment for a particular target device:

```
make -B USB_PORT=[PORT] UAS_TARGET=[TARGET] flow-speculation-jump-shadow-0
```

Where:
- `[PORT]` Is the UART/Serial port to communicate with it over.
- `[TARGET]` Is one of the target names listed in @ref targets

This will run all of the build, program, capture and analyse steps for
the experiment on the specified target.

The individual steps of the experiment are run with the following commands:

- Build: `make build_[TARGET]_speculation-jump-shadow-0`
- Program: `make program_[TARGET]_speculation-jump-shadow-0`
- Capture: `make capture_[TARGET]_speculation-jump-shadow-0 USB_PORT=[PORT]`
- Analyse: `make analyse_[TARGET]_speculation-jump-shadow-0`

*/

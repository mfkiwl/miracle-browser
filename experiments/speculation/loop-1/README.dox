/*!

@defgroup experiments-speculation-loop-1 Loop Branch Shadow 1
@ingroup  experiments-speculation
@brief Do we see leakage from un-executed/partially executed instructions?

@see @ref experiments-speculation-jump-shadow-0
@see @ref experiments-speculation-loop-0
@see @ref experiments-speculation-loop-1

## Purpose:

Identical to @ref experiments-speculation-loop-1 but with a single
`nop` between the loop branch instruction and the target `xor`.

## Method:

See  @ref experiments-speculation-loop-1 .


## Expectations:

- If either the "always predict taken" or "always predict taken if backwards"
  static branch prediction rules are implemented, then we should never
  see the `xor` instruction leakage.

  - Note that this experiment assumes that the target device has a leaky
    branch shadow of depth at-least `2`.

  - If that assumption does not hold, no leakage will be visible.

## Running the experiment

To run all stages of the experiment for a particular target device:

```
make -B USB_PORT=[PORT] UAS_TARGET=[TARGET] flow-speculation-loop-1
```

Where:
- `[PORT]` Is the UART/Serial port to communicate with it over.
- `[TARGET]` Is one of the target names listed in @ref targets

This will run all of the build, program, capture and analyse steps for
the experiment on the specified target.

The individual steps of the experiment are run with the following commands:

- Build: `make build_[TARGET]_speculation-loop-1`
- Program: `make program_[TARGET]_speculation-loop-1`
- Capture: `make capture_[TARGET]_speculation-loop-1 USB_PORT=[PORT]`
- Analyse: `make analyse_[TARGET]_speculation-loop-1`

*/

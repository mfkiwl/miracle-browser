/*!

@defgroup experiments-memory-bus-width Memory Bus Width - Bytes
@brief Can we discover memory bus widths from leakage analysis?
@ingroup  experiments-memory

@tableofcontents

## Background

CPUs with a 32-bit internal datapath or word width will often use
a 32-bit wide memory bus.

Most bus standards work in terms of word widths only, and for reads
in particular, cannot specify a sub-word memory access.
Write accesses use per-byte strobe lines.

## Purpose:

Generally, this experiment seeks to answer the question:
"When loading a byte from memory, is *only* that byte operated on by
the memory hierarchy and the SoC, or do we also get other surrounding
bytes?"

Specific questions arrising from this:
- Given that other bytes are also operated on, which bytes are these?
- Do the loaded bytes correspond to a particular memory word alignment?

## Method:

When capturing the data:

- Define 2 `N` byte arrays:
  - The `zeros` array, which always contains zeros.
  - The `din` array, which contains all zeros except from some byte index
    `I`, which acts as the fixed/random variable in a TTest.
- The variable `O`, is an offset into the `din` and `zeros` arrays.
- For each value of `O` in some range, execute the following sequence of
  operations.
  - Load the `O`'th byte from the `zeros` array. This is to *flush* the
    memory load data path from any previous accesses so that they don't
    polute the experimnet.
  - Load the `O`'th byte from the `din` array. This is the critical
    operation we observe in the TTest.
  - Load the `O`'th byte from the `zeros` array again to flush the path.
- Repeat the experiment, strobing through different values of `O` and `I`.

When interpreting the results:

- If `O` == `I`, we should expect to see first order leakage in a
  standard non-specific TTest.
- If `O` != `I`
  - If we see leakage, this means that despite asking for a constantly
    zero'd byte, we still see the `I`'th byte being manipulated by the
    SoC.
  - If we do not see leakage, then the `I`'th byte has not been manipulated.

## Expectations:

We expect to see either:

- No leakage when loading bytes other than the one at position `I`.

- Leakage when loading all bytes in the range `I-(I%4)` to `(I-(I%4))+3).

  - This would imply that whenever a byte is loaded, the entire word in
    which it resides is in fact manipulated and presented to the CPU,
    which then throws away the extra bytes.

## Findings

@todo Re-write bus-width-bytes experiment findings with new results.

### Overview:

- All targets are 32-bit platforms, and unsupprisingly, we found that the
  bus widths are 32-bits wide for all targets.

- We also found that if a word-aligned byte is fetched, other bytes are
  also transfered *in some way* between the memory and the CPU.
  - These extra bytes do not get committed to architectural state.
  - They are clearly visible in the T-test traces.

- For pre-existing systems, we now know that this is an effect which
  can be identified reasonably easily.

- For new systems being designed, we have some recommendations about how
  to augment a given bus standard, or bus standard implementation, to
  increase leakage resiliance.

### Discussion:

- Though the results are not supprising from a micro-architecture point of
  view, the result that more than the requested number of bytes are
  transfered has serious implications for side-channel analysis.

- The result was expected given knowledge of the bus architectures used
  in the target systems:

- The ARM microcontrollers all use AMBA AHB bus standards to communicate
  intra-chip. This standard allows for transfer sizes which are
  power-of-two numbers of bytes, *upto the width of the bus*.
  - This means that in a 32-bit bus, 1,2 or 4 bytes may be read or written
    by a bus master.
  - The width of the data transfer is controlled by the `HSIZE` signal,
    and the address (`HADDR`) does not need to be word aligned.
  - However, it appears that the tested CPU implementations *either* 
    a) always request an entire word, and throw away un-needed bytes or
    b) request only what they need, but the *memory device* always
       returns an entire word.
  - The net result is that more bytes than were requested are driven
    across the bus.

- The Xilinx FPGA softcore systems were set-up to use both ARM AXI 4.0
  busses[2], and Xilinx's own Local-Memory-Bus (LMB) standard [3].
  - AXI4 busses allow multiple transaction memory accesses. The number of
    bytes transfered per beat is specified by `ARSIZE`/`AWSIZE` for
    reads/writes respectivley. The number of beats in the burst is then
    controlled by the `ARLEN`/`AWLEN` signals.
  - The AXI4-Lite protocol simplifies this by forcing all bursts to
    have only 1 beat (`A*LEN = 1`) and all accesses are 
    *"the full width of the data bus"* (`A*SIZE = 4/8`).
    Busses may be *"32-bit or 64-bit"* wide.
  - Clearly, the AXI4-Lite protocol is inherently problematic from the
    perspective of fetching more bytes than are actually required by the
    core.
  - The full fat AXI4 protocol *may* also suffer from this problem, but
    that is *heavily* implementation dependent.

- The Xilinx LMB bus protocol is *"used as the LMB interconnect for Xilinx
  device embedded processor systems. The LMB is a fast, local bus for
  connecting the MicroBlazeâ„¢ processor instruction and data ports to
  high-speed peripherals, primarily on-chip block RAM (BRAM)."*[3,
  4 (chapter 3, p163)]
  - Particularly, it allows *single cycle* access to on-chip BRAM.
  - As with AXI4-Lite, it has no way of requesting less than 1-bus widths
    data from a slave device, meaning that even if a single byte is requested,
    and entire word of data is returned by the BRAM.

- It is clear that this extra, unexpected activity on data memory busses
  has undesirable implications for side-channel resiliance.

- We suggest that side-channel resilliant CPU and software design can only go
  so far in mitigating these vulnrabilities.

- There are some fundamental questions which instances of the examinied bus
  standards and target platforms must answer from a side channel perspective.
  - Clear documentation about sub-bus-word data transfer behaviour.
  - Clear per-perhiperhal documentation about how they fill redundant
    bytes of the data bus.
  - Clear documentation about which subset of possible bus behaviors the
    CPU engages in: Does is always request words and discard as needed?
    Does it always only request what is needs, but gets extra stuff anyway?

- These questions must be answered for *existing* systems. We also suggest
  the following guidelines for system *designers and implementers*, in the
  hope that future system interconnects can take pro-active steps to design
  with leakage resiliance in mind.
  - Almost all bus standards include some form of "write strobe" bits,
    which allow individual bytes within a 32-bit data word to be
    included or omitted from a memory write operation.
  - We suggest it makes sense to include corresponding "read strobe"
    lines, that can be used by a bus master to indicate exactly which
    bytes of the requested data it is interested in. Bus slaves can then
    return *only* the data requested.
  - When implementing (as opposed to specifying, as above) as bus standard,
    redundant bytes can be used to implement rudimentary countermeasures
    e.g. driving redundant bytes to the complement of used bytes, or
    even randomising their value.

## Running the experiment

To run all stages of the experiment for a particular target device:

```
make -B USB_PORT=[PORT] UAS_TARGET=[TARGET] flow-memory-bus-bus-width-bytes
```

Where:
- `[PORT]` Is the UART/Serial port to communicate with it over.
- `[TARGET]` Is one of the target names listed in @ref targets

This will run all of the build, program, capture and analyse steps for
the experiment on the specified target.

The individual steps of the experiment are run with the following commands:

- Build: `make build_[TARGET]_memory-bus-width-bytes`
- Program: `make program_[TARGET]_memory-bus-width-bytes`
- Capture: `make capture_[TARGET]_memory-bus-width-bytes USB_PORT=[PORT]`
- Analyse: `make program_[TARGET]_memory-bus-width-bytes`

## References

1. [ARM AMBA 5 AHB Protocol Specification AHB5, AHB-Lite](https://static.docs.arm.com/ihi0033/bb/IHI0033B_B_amba_5_ahb_protocol_spec.pdf)
2. [ARM AMBA AXI and ACE Protocol Specification AXI3, AXI4, AXI5, ACE and ACE5](https://static.docs.arm.com/ihi0022/fb/IHI0022F_b_amba_axi_protocol_spec.pdf)
3. [Xilinx Local Memory Bus (LMB) v3.0 LogiCORE IP Product Guide](https://www.xilinx.com/support/documentation/ip_documentation/lmb_v10/v3_0/pg113-lmb-v10.pdf)
4. [Xilinx UG984 Microblaze Processor Reference Guide](https://www.xilinx.com/support/documentation/sw_manuals/xilinx2018_3/ug984-vivado-microblaze-ref.pdf)

*/

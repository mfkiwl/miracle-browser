/*!

@defgroup experiments-memory-registers-ld-byte Registers - Load Byte
@ingroup  experiments-memory
@brief Are there un-documented registers in the memory load path?

@see @ref experiments-memory-registers-ld-byte
@see @ref experiments-memory-registers-st-byte
@see @ref experiments-memory-registers-implicit-ld-1
@see @ref experiments-memory-registers-implicit-ld-2

## Background

While pipeline registers and registers inside the CPU more generally
must be considered from a leakage perspective, so too must any registers
in the memory hierarchy.
These tend to be even more opaque than CPU registers.
One may assume for a given pipeline stage, that some data is
registered by that stage.
Pipeline structure (however roughly) is often available to the programmer.
Even the number of stages and their names can help with this.
For the memory hierarchy, such information is almost never available,
so techniques for deducing such behaviour emprically are needed.

## Purpose:

To discover if there are any un-expected registers which could cause
hamming weight or distance leakage related to the data load path.

## Method:

- Start with two arrays:
  - A `zeros` array, which contains only zeros.
  - A `din` array, which is all zeros except for two elements.
    - `idx1` and `idx2` are indicies within the array, which point
      to variables which are randomised or fixed as part of a TTest.
    - The exact values of `idx1` and `idx2` are parameters to the test,
      allowing the affect of crossing word boundaries to be investigated.
  - Before each run of the experiment, the array elements at
    `idx1` and `idx2` are both set to either fixed or random values.
    - Both the fixed or random values are xor'd with *the same* mask
      variable, which is uniformly random and re-generated for each
      test iteration.
    - Hence, when loading the values at `idx1` and `idx2`, we should
      only see leakage iff their values are combined.
- Run the following experiment kernel
  - Load a byte from the zeros array to clear the load data path and
    assoicated registers as best we can.
  - Load the value at `idx1` into a CPU register.
  - Load the value at `idx2` into a different CPU register.
  - Load a byte from the zeros array again.


## Expectations:

If there are no state elements in the data load path, we should
not see the values at `idx1` and `idx2` interract, and hence not see
any first order leakage peaks.

If there are state elements which remember the last loaded value, we
would expect that loading the value at `idx1` will set it's value
in a register.
Then loading the value at `idx2` causes an overwrite, which, because
they are masked with the same value, will cause first order
hamming distance leakage.
We would expect then that the first load of `idx1` would never leak,
but the load of `idx2` would always leak iff there is some intermediate
storage of loaded values.

Clearly, this would undermine a masking scheme which doesn't
compensate for the effect.

## Findings

@todo Re-write registers-ld-byte experiment findings with new results.

## Running the experiment

To run all stages of the experiment for a particular target device:

```
make -B USB_PORT=[PORT] UAS_TARGET=[TARGET] flow-memory-bus-registers-ld-byte
```

Where:
- `[PORT]` Is the UART/Serial port to communicate with it over.
- `[TARGET]` Is one of the target names listed in @ref targets

This will run all of the build, program, capture and analyse steps for
the experiment on the specified target.

The individual steps of the experiment are run with the following commands:

- Build: `make build_[TARGET]_memory-bus-registers-ld-byte`
- Program: `make program_[TARGET]_memory-bus-registers-ld-byte`
- Capture: `make capture_[TARGET]_memory-bus-registers-ld-byte USB_PORT=[PORT]`
- Analyse: `make program_[TARGET]_memory-bus-registers-ld-byte`

## References

1. [ARM AMBA 5 AHB Protocol Specification AHB5, AHB-Lite](https://static.docs.arm.com/ihi0033/bb/IHI0033B_B_amba_5_ahb_protocol_spec.pdf)
2. [ARM AMBA AXI and ACE Protocol Specification AXI3, AXI4, AXI5, ACE and ACE5](https://static.docs.arm.com/ihi0022/fb/IHI0022F_b_amba_axi_protocol_spec.pdf)
3. [Xilinx Local Memory Bus (LMB) v3.0 LogiCORE IP Product Guide](https://www.xilinx.com/support/documentation/ip_documentation/lmb_v10/v3_0/pg113-lmb-v10.pdf)
4. [Xilinx UG984 Microblaze Processor Reference Guide](https://www.xilinx.com/support/documentation/sw_manuals/xilinx2018_3/ug984-vivado-microblaze-ref.pdf)

*/
